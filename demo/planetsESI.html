<!DOCTYPE html>
<html>
<head lang="en">
    <title>Planets ESI Demo</title>

    <link rel="stylesheet" href="demos.css">
    <script type="text/javascript" src="../dist/ccpwgl2_int.js"></script>
    <script type="text/javascript" src="../dist/ccpwgl.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
    <script type="text/javascript" src="demos.js"></script>

    <script type="text/javascript">

        let canvas, camera, scene, planets = [], selectionText = "Alt + left click planet to zoom";

        async function OnDocLoad()
        {
            const {esi} = ccpwgl;
            const {mat4, vec2, vec3, vec4, ray3, sph3} = tw2.math;

            // Load system
            const systemID = tw2.util.getURLInteger("system", 30002053);
            const system = await esi.getSystem(systemID);
            const {nebulaPath, lensflarePath} = await esi.getSystemGraphicData(systemID);

            // Create scene
            ccpwgl.initialize("mainCanvas", demos.options);
            canvas = ccpwgl.canvas;
            camera = ccpwgl.createCamera();
            scene = ccpwgl.loadScene(nebulaPath);
            scene.treatPlanetsAsObjects(true);
            scene.loadSun(lensflarePath);


            let planetsData = [],
                maxRadius = 0;

            // Get raw data for each planet and identify biggest radius
            system.planets.forEach(planet =>
            {
                if (planet && planet.planet_id)
                {
                    planetsData.push(esi.getPlanetGraphicData(planet.planet_id)
                        .then(data =>
                        {
                            // Scale planets down to reduce floating point errors when ray casting
                            data.radius /= 1000;
                            maxRadius = Math.max(maxRadius, data.radius * 3);
                            return data;
                        }));
                }
            });

            // Wait until all planets are loaded
            planetsData = await Promise.all(planetsData);

            // Sort planets by biggest to smallest
            planetsData.sort((a, b) => a.radius > b.radius ? 1 : -1);

            // Build planets
            planetsData.forEach(planet =>
            {
                planets.push(scene.loadPlanet(planet, function()
                {
                    const
                        angle = Math.PI * 2 * planetsData.indexOf(planet) / planetsData.length,
                        {radius, name} = planet;

                    this.transform.From({
                        scale: radius,
                        translation: [maxRadius * Math.cos(angle), 0, maxRadius * Math.sin(angle)]
                    });

                    console.log(`Loaded ${name}`);
                }));
            });

            const
                mousePosition = vec2.create(),
                closestPoint = vec3.create(),
                viewport = vec4.create(),
                rayCast = ray3.create(),
                boundingSphere = sph3.create(),
                viewProjectionInverse = mat4.create(),
                transform = mat4.create();

            // Updates mouse coordinates
            canvas.addEventListener("mousemove", function(event)
            {
                mousePosition[0] = event.clientX;
                mousePosition[1] = tw2.height - event.clientY;
            });

            // Ray intersection test for planets
            canvas.addEventListener("mousedown", function(event)
            {
                if (!event.altKey) return;

                vec4.set(viewport, 0, 0, tw2.width, tw2.height);
                mat4.invert(viewProjectionInverse, tw2.device.viewProjection);
                ray3.unproject(rayCast, mousePosition, viewProjectionInverse, viewport);

                const closest = {
                    planet: null,
                    distance: Infinity,
                    point: null
                };

                planets.forEach(planet =>
                {
                    planet.transform.GetWorldTransform(transform);
                    sph3.fromMat4(boundingSphere, transform);
                    if (ray3.getIntersectSph3(closestPoint, rayCast, boundingSphere))
                    {
                        const distance = ray3.squaredDistance(rayCast, closestPoint);
                        if (distance < closest.distance)
                        {
                            closest.distance = distance;
                            closest.planet = planet;
                            closest.point = Array.from(closestPoint);
                        }
                    }
                });

                if (closest.planet)
                {
                    closest.planet.transform.GetWorldTranslation(camera.poi);
                    camera.distance = closest.planet.transform.GetWorldMaxScale() * 4;
                    selectionText = closest.planet.name;
                }

                event.preventDefault();
            });

            // Show when stuff is loading
            ccpwgl.on("pre_render", () =>
            {
                document.getElementById("loading").innerHTML = ccpwgl.isLoading() ? "loading" : `<b>${selectionText}</b>`;
            });
        }
    </script>

</head>
<body onload="OnDocLoad()">
<canvas id="mainCanvas" width="500" height="500"></canvas>
<div id="loading">Loading...</div>
</body>
</html>
